/*
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. 
 * If a copy of the MPL was not distributed with this file, You can obtain one at
 *  http://mozilla.org/MPL/2.0/. 
 *
 * Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006 National Research Council of Canada 
 * 
 * This software was initially developed at the National Research Council of Canada (NRC).
 *
 * THE NATIONAL RESEARCH COUNCIL OF CANADA MAKES NO REPRESENTATIONS OR
 * WARRANTIES ABOUT THE SUITABILITY OF THE SOFTWARE, EITHER EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.
 * THE NATIONAL RESEARCH COUNCIL OF CANADA SHALL NOT BE LIABLE FOR ANY DAMAGES
 * SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING
 * THIS SOFTWARE OR ITS DERIVATIVES.
 *
 *
 */


package nrc.fuzzy;

import java.io.*;

/**
 * Implements the FuzzyRuleExecutor interface providing an execute method
 * that accepts a FuzzyRule object and returns a FuzzyValueVector composed
 * of the actual conclusion FuzzyValues for the rule using the
 * Tsukamoto rule firing method. This rule executor does expect that the
 * output fuzzy values have special fuzzy sets. Each of the output fuzzy sets 
 * should be either a strictly increasing function with membership values from 0.0
 * to 1.0 or a strictly decreasing function with membership values from 1.0 to 0.0. 
 * For example, an SFuzzySet is strictly increasing from 0.0 at its left 
 * limit to 1.0 at its right limit. Then the outputs are generated from the
 * conclusions by using the DOF (Degree of Fulfillment of the rule) which
 * is determined by the current AntecedentCombineOperator. This is normally the
 * MinimumAntecedentCombineOperator which calculates the maxmum membership 
 * values for all of the intesections between the input and antecedent fuzzy
 * values and takes the minimum of those. Then using this DOF value outputs
 * are generated by finding the X value that corresponds to this DOF in the
 * conclusion fuzzy sets. With the X values singleton fuzzy sets are 
 * created with a maximum membership value equal to the DOF. Since the conclusions
 * were represented by special strictly increasing or decreasing functions,
 * the X values will be unique. To complete the Tsukamoto method the output 
 * fuzzy values should combined (global contribution) using the fuzzySum method
 * and then defuzzified using the weightedAverageDefuzzify method.
 * <br><br>
 * Should the rule be fired a second time and the antecedents and inputs have not 
 * changed, it is only necessary to use the DOF already calculated to generate 
 * the outputs the consequents, avoiding some expensive calculations. 
 * <br> 
 * NOTE: In order to do this optimization it is required 
 * the the executor NOT be shared amongst rules. In effect each rule must have its
 * own unique instance of the executor. This is enforced in Rule creation, since
 * each RuleExecutor must implement the cloneable interface and provide a clone method.
 *
 * @author Bob Orchard
 *
 * @see LarsenProductMaxMinRuleExecutor
 * @see MandaniMinMaxMinRuleExecutor
 * @see FuzzyRuleExecutor
 * @see AntecedentCombineOperator
 * @see MinimumAntecedentCombineOperator
 * @see ProductAntecedentCombineOperator
 */

public class TsukamotoRuleExecutor extends FuzzyRuleExecutor
                                           implements Serializable
{
    // The degree of matching (or DOF -- Degree of rule Fullfillment)
	// for the antecedents and inputs. This value
    // is maintained from rule execution to rule execution. It is expected that
    // any FuzzyRuleExecutor will not be shared amongst rules (i.e. each
    // FuzzyRule has its own FuzzyRuleExecutor) so that we can maintain
    // state between rule firings as required for any FuzzyRuleExecutor.
    // In this case we can reuse the previous calculation of DOF (Degree of
    // Fulfillment of the rule ... i.e. how well the antecedents match their 
    // corresponding actual fuzzy values) if the method of calculating the DOF
    // (minimum or product etc. -- depending on the AntecedentCombineOperator) and the
    // antecedents and inputs have not changed since the last rule firing.
    // This allows one to change the conclusion(s) of the rule and fire it again
    // with the same inputs/antecedents without the overhead of recalulating
    // DOF each time.
    //
    // DOF is the minimum (or product etc.) of the maximum intersection values of all the
    // antecedent/input fuzzy value pairs.
    private double DOF;

    /**
     * Implements the required cloning of a RuleExecutor.
     *
     * @return the newly cloned RuleExecutor
     */
    public Object clone() 
    {
      try 
      {
      	TsukamotoRuleExecutor re = (TsukamotoRuleExecutor)super.clone();
        re.DOF = this.DOF;
        return re;
      } 
      catch (Exception e) 
      {
        // this shouldn't happen because this is Cloneable
        throw new InternalError();
      }
    }
          
          
    /**
     * This execute method implements rule execution using the 
     * Tsukamoto method.
     * Classes that implement the FuzzyRuleExecutor interface must provide
     * an execute method that accepts a FuzzyRule object and 
     * returns a FuzzyValueVector composed of the actual output FuzzyValues
     * for the rule. 
     * 
     * @param fuzzyRule the rule that is to be executed (fired)
     * @return A FuzzyValueVector with the FuzzyValues that represent the
     *          outputs of the fired rule.
     * @exception IncompatibleRuleInputsException
     */
    public FuzzyValueVector execute( FuzzyRule rule )
        throws IncompatibleRuleInputsException
    {
        boolean recalulateDOF = (rule.isAntecedentsChanged() || rule.isInputsChanged() ||
		                         rule.isAntecendentCombineOperatorChanged());

        return doTheExecute( rule.getAntecedents(), rule.getConclusions(),
                             rule.getInputs(), rule.getAntecedentCombineOperator(), 
                             recalulateDOF );
    }
    
    /**
     * This execute method implements rule execution using the 
     * Tsukamoto method.
     * Classes that implement the FuzzyRuleExecutor interface must provide
     * an execute method that accepts 3 FuzzyValueVector objects and 
     * returns a FuzzyValueVector composed of the actual output FuzzyValues
     * for the rule. 
     *
     * @param antecedents The FuzzyValues that represent a rule's antecedents.
     * @param conclusions The FuzzyValues that represent a rule's conclusions.
     * @param inputs The FuzzyValues that represent a rule's inputs.
     * @return A FuzzyValueVector with the FuzzyValues that represent the
     *          outputs of the fired rule.
     * @exception IncompatibleRuleInputsException
     */
    public FuzzyValueVector execute( FuzzyValueVector antecedents, 
                                     FuzzyValueVector conclusions, 
                                     FuzzyValueVector inputs )
        throws IncompatibleRuleInputsException
    {
        // in this case the DOF must always be re-calulated since there is no rule
        // that stores the antecedents and inputs from one invocation to the next
        // and use the default antecedentCombineOperator without a rule
        return doTheExecute( antecedents, conclusions, inputs, 
                             FuzzyRule.getDefaultAntecedentCombineOperator(), true );
    }
    
    /**
     * This execute method does the work of the execute method.
     *
     * @param antecedents The FuzzyValues that represent a rule's antecedents.
     * @param conclusions The FuzzyValues that represent a rule's conclusions.
     * @param inputs The FuzzyValues that represent a rule's inputs.
     * @param combineOperator the operator to use when combining the match values
     *                        for the antecedent/input pairs
     * @param recalculateDOF True if we need to recalculate the DOF since the
     *                       antecedents or inputs of the rule have changed.
     * @return A FuzzyValueVector with the FuzzyValues that represent the
     *          outputs of the fired rule.
     * @exception IncompatibleRuleInputsException
     */
    private FuzzyValueVector doTheExecute( FuzzyValueVector antecedents, 
                                           FuzzyValueVector conclusions, 
                                           FuzzyValueVector inputs,
	                                       AntecedentCombineOperator combineOperator,
                                           boolean recalulateDOF 
                                         )
        throws IncompatibleRuleInputsException
    {
        int i;
        FuzzyValueVector outputs;
        double tempDOF;

        // antecedents and inputs must be same size and have matching FuzzyVariables
        FuzzyRule.checkAntecedentsAndInputs( antecedents, inputs );
        
        // now we can create the outputs -- if size of conslusions is zero
        // return an empty FuzzyValueVector;
        if (conclusions.size() == 0)
            return new FuzzyValueVector(1);

        outputs = new FuzzyValueVector( conclusions.size() );

        if (recalulateDOF)
        { // we must recalculate DOF
		  int len = antecedents.size();
          DOF = 1.0;
          if (len > 0)
          { try
			{ double matchValues[] = new double[len];
			  for (i = 0; i<len; i++)
			  { matchValues[i] = antecedents.fuzzyValueAt(i).maximumOfIntersection(inputs.fuzzyValueAt(i));
			  }
			  DOF = (len == 1)? matchValues[0] :
								combineOperator.execute(matchValues);
			}
			catch (IncompatibleFuzzyValuesException e)
			{   tempDOF = 1.0; } // safe to ignore this since we already checked compatibility
          }
        }

        // now calc actual conclusions using the DOF to find the corresponding X
        // value with the DOF membership value (expects conclusions are
        // special strictly increasing or strictly descreasing functions that
        // cover all membership values from 0.0 to 1.0).
        // If there is no X value with the required DOF membership value in a
        // conclusion then use an output fuzzy value with all zero membership
        // values. The method to find the X value will generate an exception
        // in this case. This should not happen if the user has the proper
        // conclusion FuzzySets spanning all membership values from 0.0 to 1.0.
        double xVals[] = new double[3];
        double yVals[] = {0.0, DOF, 0.0};
        for (i = 0; i<conclusions.size(); i++)
        {   double xValue;
        	int len = 3;
        	FuzzyValue conc = conclusions.fuzzyValueAt(i);
        	try
			{   xValue = conc.getXforMembership(DOF);
        		xVals[0] = xVals[1] = xVals[2] = xValue;
			}
        	catch (NoXValueForMembershipException e)
			{	// generate a FuzzyValue with 0 membership everywhere (single pt at (x,0.0))
        		len = 1; //use 1st element of the arrays to generate the FuzzyValue
        		xVals[0] = conc.getMinUOD(); // use a valid x value for the fuzzy set
			}
        	try
			{    outputs.addFuzzyValue(new FuzzyValue(conc.getFuzzyVariable(), xVals, yVals, len));
			}
			catch (FuzzyException e) // cannot happen since the values are proper
			{}
        }

        return outputs;
    }
    
}
